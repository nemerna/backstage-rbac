'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var errors = require('@backstage/errors');
var jose = require('jose');

function getBearerTokenFromAuthorizationHeader(authorizationHeader) {
  if (typeof authorizationHeader !== "string") {
    return void 0;
  }
  const matches = authorizationHeader.match(/^Bearer[ ]+(\S+)$/i);
  return matches == null ? void 0 : matches[1];
}

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const CLOCK_MARGIN_S = 10;
class DefaultIdentityClient {
  constructor(options) {
    __publicField$1(this, "discovery");
    __publicField$1(this, "issuer");
    __publicField$1(this, "algorithms");
    __publicField$1(this, "keyStore");
    __publicField$1(this, "keyStoreUpdated", 0);
    this.discovery = options.discovery;
    this.issuer = options.issuer;
    this.algorithms = options.hasOwnProperty("algorithms") ? options.algorithms : ["ES256"];
  }
  /**
   * Create a new {@link DefaultIdentityClient} instance.
   */
  static create(options) {
    return new DefaultIdentityClient(options);
  }
  async getIdentity(options) {
    const {
      request: { headers }
    } = options;
    if (!headers.authorization) {
      return void 0;
    }
    try {
      return await this.authenticate(
        getBearerTokenFromAuthorizationHeader(headers.authorization)
      );
    } catch (e) {
      throw new errors.AuthenticationError(e.message);
    }
  }
  /**
   * Verifies the given backstage identity token
   * Returns a BackstageIdentity (user) matching the token.
   * The method throws an error if verification fails.
   *
   * @deprecated You should start to use getIdentity instead of authenticate to retrieve the user
   * identity.
   */
  async authenticate(token) {
    if (!token) {
      throw new errors.AuthenticationError("No token specified");
    }
    await this.refreshKeyStore(token);
    if (!this.keyStore) {
      throw new errors.AuthenticationError("No keystore exists");
    }
    const decoded = await jose.jwtVerify(token, this.keyStore, {
      algorithms: this.algorithms,
      audience: "backstage",
      issuer: this.issuer
    });
    if (!decoded.payload.sub) {
      throw new errors.AuthenticationError("No user sub found in token");
    }
    const user = {
      token,
      identity: {
        type: "user",
        userEntityRef: decoded.payload.sub,
        ownershipEntityRefs: decoded.payload.ent ? decoded.payload.ent : []
      }
    };
    return user;
  }
  /**
   * If the last keystore refresh is stale, update the keystore URL to the latest
   */
  async refreshKeyStore(rawJwtToken) {
    const payload = await jose.decodeJwt(rawJwtToken);
    const header = await jose.decodeProtectedHeader(rawJwtToken);
    let keyStoreHasKey;
    try {
      if (this.keyStore) {
        const [_, rawPayload, rawSignature] = rawJwtToken.split(".");
        keyStoreHasKey = await this.keyStore(header, {
          payload: rawPayload,
          signature: rawSignature
        });
      }
    } catch (error) {
      keyStoreHasKey = false;
    }
    const issuedAfterLastRefresh = (payload == null ? void 0 : payload.iat) && payload.iat > this.keyStoreUpdated - CLOCK_MARGIN_S;
    if (!this.keyStore || !keyStoreHasKey && issuedAfterLastRefresh) {
      const url = await this.discovery.getBaseUrl("auth");
      const endpoint = new URL(`${url}/.well-known/jwks.json`);
      this.keyStore = jose.createRemoteJWKSet(endpoint);
      this.keyStoreUpdated = Date.now() / 1e3;
    }
  }
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class IdentityClient {
  constructor(defaultIdentityClient) {
    __publicField(this, "defaultIdentityClient");
    this.defaultIdentityClient = defaultIdentityClient;
  }
  static create(options) {
    return new IdentityClient(DefaultIdentityClient.create(options));
  }
  /**
   * Verifies the given backstage identity token
   * Returns a BackstageIdentity (user) matching the token.
   * The method throws an error if verification fails.
   *
   * @deprecated You should start to use IdentityApi#getIdentity instead of authenticate
   * to retrieve the user identity.
   */
  async authenticate(token) {
    return await this.defaultIdentityClient.authenticate(token);
  }
}

exports.DefaultIdentityClient = DefaultIdentityClient;
exports.IdentityClient = IdentityClient;
exports.getBearerTokenFromAuthorizationHeader = getBearerTokenFromAuthorizationHeader;
//# sourceMappingURL=index.cjs.js.map
