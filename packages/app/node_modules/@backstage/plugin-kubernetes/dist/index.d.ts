/// <reference types="react" />
import * as _backstage_core_plugin_api from '@backstage/core-plugin-api';
import { OAuthApi, OpenIdConnectApi, DiscoveryApi, IdentityApi } from '@backstage/core-plugin-api';
import * as React from 'react';
import React__default from 'react';
import { Entity } from '@backstage/catalog-model';
import { KubernetesRequestBody, ObjectsByEntityResponse, WorkloadsByEntityRequest, CustomObjectsByEntityRequest, ClusterObjects, ClusterAttributes, ClientContainerStatus, CustomResourceMatcher, ClientPodStatus } from '@backstage/plugin-kubernetes-common';
import * as kubernetes_models_v1 from 'kubernetes-models/v1';
import { Event, Pod, IContainer, IContainerStatus } from 'kubernetes-models/v1';
import { JsonObject } from '@backstage/types';
import { V1Pod, V1ReplicaSet, V1Deployment, V1HorizontalPodAutoscaler, V1Service, V1ConfigMap, V1Ingress, V1Job, V1CronJob, V1StatefulSet, V1ObjectMeta } from '@kubernetes/client-node';
import { IObjectMeta, IIoK8sApimachineryPkgApisMetaV1ObjectMeta } from '@kubernetes-models/apimachinery/apis/meta/v1/ObjectMeta';
import * as react_use_lib_useAsyncFn from 'react-use/lib/useAsyncFn';
import { Pod as Pod$1 } from 'kubernetes-models/v1/Pod';
import { TypeMeta } from '@kubernetes-models/base';

declare const kubernetesPlugin: _backstage_core_plugin_api.BackstagePlugin<{
    entityContent: _backstage_core_plugin_api.RouteRef<undefined>;
}, {}, {}>;
/**
 * Props of EntityKubernetesContent
 *
 * @public
 */
type EntityKubernetesContentProps = {
    /**
     * Sets the refresh interval in milliseconds. The default value is 10000 (10 seconds)
     */
    refreshIntervalMs?: number;
};
declare const EntityKubernetesContent: (props: EntityKubernetesContentProps) => JSX.Element;

declare const isKubernetesAvailable: (entity: Entity) => boolean;
declare const Router: (props: {
    refreshIntervalMs?: number;
}) => React__default.JSX.Element;

declare const kubernetesApiRef: _backstage_core_plugin_api.ApiRef<KubernetesApi>;
declare const kubernetesProxyApiRef: _backstage_core_plugin_api.ApiRef<KubernetesProxyApi>;
interface KubernetesApi {
    getObjectsByEntity(requestBody: KubernetesRequestBody): Promise<ObjectsByEntityResponse>;
    getClusters(): Promise<{
        name: string;
        authProvider: string;
        oidcTokenProvider?: string | undefined;
    }[]>;
    getWorkloadsByEntity(request: WorkloadsByEntityRequest): Promise<ObjectsByEntityResponse>;
    getCustomObjectsByEntity(request: CustomObjectsByEntityRequest): Promise<ObjectsByEntityResponse>;
    proxy(options: {
        clusterName: string;
        path: string;
        init?: RequestInit;
    }): Promise<Response>;
}
interface KubernetesProxyApi {
    getPodLogs(request: {
        podName: string;
        namespace: string;
        clusterName: string;
        containerName: string;
        previous?: boolean;
    }): Promise<{
        text: string;
    }>;
    getEventsByInvolvedObjectName(request: {
        clusterName: string;
        involvedObjectName: string;
        namespace: string;
    }): Promise<Event[]>;
}

interface KubernetesAuthProvider {
    decorateRequestBodyForAuth(requestBody: KubernetesRequestBody): Promise<KubernetesRequestBody>;
    getCredentials(): Promise<{
        token?: string;
    }>;
}
declare const kubernetesAuthProvidersApiRef: _backstage_core_plugin_api.ApiRef<KubernetesAuthProvidersApi>;
interface KubernetesAuthProvidersApi {
    decorateRequestBodyForAuth(authProvider: string, requestBody: KubernetesRequestBody): Promise<KubernetesRequestBody>;
    getCredentials(authProvider: string): Promise<{
        token?: string;
    }>;
}

declare class KubernetesAuthProviders implements KubernetesAuthProvidersApi {
    private readonly kubernetesAuthProviderMap;
    constructor(options: {
        microsoftAuthApi: OAuthApi;
        googleAuthApi: OAuthApi;
        oidcProviders?: {
            [key: string]: OpenIdConnectApi;
        };
    });
    decorateRequestBodyForAuth(authProvider: string, requestBody: KubernetesRequestBody): Promise<KubernetesRequestBody>;
    getCredentials(authProvider: string): Promise<{
        token?: string;
    }>;
}

declare class GoogleKubernetesAuthProvider implements KubernetesAuthProvider {
    authProvider: OAuthApi;
    constructor(authProvider: OAuthApi);
    decorateRequestBodyForAuth(requestBody: KubernetesRequestBody): Promise<KubernetesRequestBody>;
    getCredentials(): Promise<{
        token: string;
    }>;
}

/**
 * No-op KubernetesAuthProvider, authorization will be handled in the kubernetes-backend plugin
 *
 * @public
 */
declare class ServerSideKubernetesAuthProvider implements KubernetesAuthProvider {
    decorateRequestBodyForAuth(requestBody: KubernetesRequestBody): Promise<KubernetesRequestBody>;
    getCredentials(): Promise<{}>;
}

declare class KubernetesBackendClient implements KubernetesApi {
    private readonly discoveryApi;
    private readonly identityApi;
    private readonly kubernetesAuthProvidersApi;
    constructor(options: {
        discoveryApi: DiscoveryApi;
        identityApi: IdentityApi;
        kubernetesAuthProvidersApi: KubernetesAuthProvidersApi;
    });
    private handleResponse;
    private postRequired;
    private getCluster;
    private getCredentials;
    getObjectsByEntity(requestBody: KubernetesRequestBody): Promise<ObjectsByEntityResponse>;
    getWorkloadsByEntity(request: WorkloadsByEntityRequest): Promise<ObjectsByEntityResponse>;
    getCustomObjectsByEntity(request: CustomObjectsByEntityRequest): Promise<ObjectsByEntityResponse>;
    getClusters(): Promise<{
        name: string;
        authProvider: string;
    }[]>;
    proxy(options: {
        clusterName: string;
        path: string;
        init?: RequestInit;
    }): Promise<Response>;
}

/**
 * A client for common requests through the proxy endpoint of the kubernetes backend plugin.
 *
 * @public
 */
declare class KubernetesProxyClient {
    private readonly kubernetesApi;
    constructor(options: {
        kubernetesApi: KubernetesApi;
    });
    private handleText;
    private handleJson;
    getEventsByInvolvedObjectName({ clusterName, involvedObjectName, namespace, }: {
        clusterName: string;
        involvedObjectName: string;
        namespace: string;
    }): Promise<Event[]>;
    getPodLogs({ podName, namespace, clusterName, containerName, previous, }: {
        podName: string;
        namespace: string;
        clusterName: string;
        containerName: string;
        previous?: boolean;
    }): Promise<{
        text: string;
    }>;
}

type FormatClusterLinkOptions = {
    dashboardUrl?: string;
    dashboardApp?: string;
    dashboardParameters?: JsonObject;
    object: any;
    kind: string;
};
declare function formatClusterLink(options: FormatClusterLinkOptions): string | undefined;

interface DeploymentResources {
    pods: V1Pod[];
    replicaSets: V1ReplicaSet[];
    deployments: V1Deployment[];
    horizontalPodAutoscalers: V1HorizontalPodAutoscaler[];
}
interface GroupedResponses extends DeploymentResources {
    services: V1Service[];
    configMaps: V1ConfigMap[];
    ingresses: V1Ingress[];
    jobs: V1Job[];
    cronJobs: V1CronJob[];
    customResources: any[];
    statefulsets: V1StatefulSet[];
}
interface ClusterLinksFormatterOptions {
    dashboardUrl?: URL;
    dashboardParameters?: JsonObject;
    object: any;
    kind: string;
}
type ClusterLinksFormatter = (options: ClusterLinksFormatterOptions) => URL;

declare const clusterLinksFormatters: Record<string, ClusterLinksFormatter>;

type ClusterProps = {
    clusterObjects: ClusterObjects;
    podsWithErrors: Set<string>;
    children?: React__default.ReactNode;
};
declare const Cluster: ({ clusterObjects, podsWithErrors }: ClusterProps) => React__default.JSX.Element;

type CronJobsAccordionsProps = {
    children?: React__default.ReactNode;
};
declare const CronJobsAccordions: ({}: CronJobsAccordionsProps) => React__default.JSX.Element;

interface CustomResourcesProps {
    children?: React__default.ReactNode;
}
declare const CustomResources: ({}: CustomResourcesProps) => React__default.JSX.Element;

type ErrorPanelProps$1 = {
    entityName: string;
    errorMessage?: string;
    clustersWithErrors?: ClusterObjects[];
    children?: React__default.ReactNode;
};
declare const ErrorPanel: ({ entityName, errorMessage, clustersWithErrors, }: ErrorPanelProps$1) => React__default.JSX.Element;

/**
 * Severity of the error, where 10 is critical and 0 is very low.
 *
 * @public
 */
type ErrorSeverity = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10;
/**
 * A list of errors keyed by Cluster name
 *
 * @public
 */
type DetectedErrorsByCluster = Map<string, DetectedError[]>;
/**
 * A reference to a Kubernetes object
 *
 * @public
 */
interface ResourceRef {
    name: string;
    namespace: string;
    kind: string;
    apiGroup: string;
}
/**
 * Represents an error found on a Kubernetes object
 *
 * @public
 */
interface DetectedError {
    type: string;
    severity: ErrorSeverity;
    message: string;
    proposedFix?: ProposedFix;
    sourceRef: ResourceRef;
    occurrenceCount: number;
}
type ProposedFix = LogSolution | DocsSolution | EventsSolution;
interface ProposedFixBase {
    errorType: string;
    rootCauseExplanation: string;
    actions: string[];
}
interface LogSolution extends ProposedFixBase {
    type: 'logs';
    container: string;
}
interface DocsSolution extends ProposedFixBase {
    type: 'docs';
    docsLink: string;
}
interface EventsSolution extends ProposedFixBase {
    type: 'events';
    podName: string;
}

/**
 * For each cluster try to find errors in each of the object types provided
 * returning a map of cluster names to errors in that cluster
 *
 * @public
 */
declare const detectErrors: (objects: ObjectsByEntityResponse) => DetectedErrorsByCluster;

type ErrorReportingProps = {
    detectedErrors: DetectedErrorsByCluster;
};
declare const ErrorReporting: ({ detectedErrors }: ErrorReportingProps) => React.JSX.Element;

/** @public */
declare const HorizontalPodAutoscalerDrawer: (props: {
    hpa: V1HorizontalPodAutoscaler;
    expanded?: boolean;
    children?: React__default.ReactNode;
}) => React__default.JSX.Element;

type IngressesAccordionsProps = {};
declare const IngressesAccordions: ({}: IngressesAccordionsProps) => React__default.JSX.Element;

type JobsAccordionsProps = {
    jobs: V1Job[];
    children?: React__default.ReactNode;
};
declare const JobsAccordions: ({ jobs }: JobsAccordionsProps) => React__default.JSX.Element;

type ErrorPanelProps = {
    cluster: ClusterAttributes;
    errorMessage?: string;
    children?: React__default.ReactNode;
};
declare const LinkErrorPanel: ({ cluster, errorMessage }: ErrorPanelProps) => React__default.JSX.Element;
interface KubernetesDrawerable {
    metadata?: V1ObjectMeta;
}
interface KubernetesStructuredMetadataTableDrawerProps<T extends KubernetesDrawerable> {
    object: T;
    renderObject: (obj: T) => object;
    buttonVariant?: 'h5' | 'subtitle2';
    kind: string;
    expanded?: boolean;
    children?: React__default.ReactNode;
}
declare const KubernetesStructuredMetadataTableDrawer: <T extends KubernetesDrawerable>({ object, renderObject, kind, buttonVariant, expanded, children, }: KubernetesStructuredMetadataTableDrawerProps<T>) => React__default.JSX.Element;

interface KubernetesObject {
    kind: string;
    metadata?: IObjectMeta;
}
interface KubernetesDrawerContentProps {
    close: () => void;
    kubernetesObject: KubernetesObject;
    header?: React__default.ReactNode;
    children?: React__default.ReactNode;
}
declare const KubernetesDrawerContent: ({ children, header, kubernetesObject, close, }: KubernetesDrawerContentProps) => React__default.JSX.Element;
interface KubernetesDrawerProps {
    open?: boolean;
    kubernetesObject: KubernetesObject;
    label: React__default.ReactNode;
    drawerContentsHeader?: React__default.ReactNode;
    children?: React__default.ReactNode;
}
declare const KubernetesDrawer: ({ open, label, drawerContentsHeader, kubernetesObject, children, }: KubernetesDrawerProps) => React__default.JSX.Element;

/**
 * Wraps a pod with the associated detected errors and cluster name
 *
 * @public
 */
interface PodAndErrors {
    clusterName: string;
    pod: Pod;
    errors: DetectedError[];
}

/**
 * Props for PodDrawer
 *
 * @public
 */
interface PodDrawerProps {
    open?: boolean;
    podAndErrors: PodAndErrors;
}
/**
 * A Drawer for Kubernetes Pods
 *
 * @public
 */
declare const PodDrawer: ({ podAndErrors, open }: PodDrawerProps) => React__default.JSX.Element;

/**
 * Contains the details needed to make a log request to Kubernetes, except the container name
 *
 * @public
 */
interface PodScope {
    podName: string;
    podNamespace: string;
    clusterName: string;
}
/**
 * Contains the details needed to make a log request to Kubernetes
 *
 * @public
 */
interface ContainerScope extends PodScope {
    containerName: string;
}

/**
 * Props for PodLogs
 *
 * @public
 */
interface PodLogsProps {
    containerScope: ContainerScope;
    previous?: boolean;
}
/**
 * Shows the logs for the given pod
 *
 * @public
 */
declare const PodLogs: React__default.FC<PodLogsProps>;

/**
 * Props for PodLogsDialog
 *
 * @public
 */
interface PodLogsDialogProps {
    containerScope: ContainerScope;
}
/**
 * Shows the logs for the given pod in a Dialog
 *
 * @public
 */
declare const PodLogsDialog: ({ containerScope }: PodLogsDialogProps) => React__default.JSX.Element;

/**
 * Arguments for usePodLogs
 *
 * @public
 */
interface PodLogsOptions {
    containerScope: ContainerScope;
    previous?: boolean;
}
/**
 * Retrieves the logs for the given pod
 *
 * @public
 */
declare const usePodLogs: ({ containerScope, previous }: PodLogsOptions) => react_use_lib_useAsyncFn.AsyncState<{
    text: string;
}>;

/**
 * Props for ContainerCard
 *
 * @public
 */
interface ContainerCardProps {
    podScope: PodScope;
    containerSpec?: IContainer;
    containerStatus: IContainerStatus;
    containerMetrics?: ClientContainerStatus;
}
/**
 * Shows details about a container within a pod
 *
 * @public
 */
declare const ContainerCard: React__default.FC<ContainerCardProps>;

/**
 * Props for PendingPodContent
 *
 * @public
 */
interface PendingPodContentProps {
    pod: Pod;
}
/**
 * Shows details about pod's conditions as it starts
 *
 * @public
 */
declare const PendingPodContent: ({ pod }: PendingPodContentProps) => React__default.JSX.Element;

/**
 * Props for FixDialog
 *
 * @public
 */
interface FixDialogProps {
    open?: boolean;
    clusterName: string;
    pod: Pod$1;
    error: DetectedError;
}
/**
 * A dialog for fixing detected Kubernetes errors
 *
 * @public
 */
declare const FixDialog: React__default.FC<FixDialogProps>;

/**
 * Props for Events
 *
 * @public
 */
interface EventsContentProps {
    warningEventsOnly?: boolean;
    events: Event[];
}
/**
 * Shows given Kubernetes events
 *
 * @public
 */
declare const EventsContent: ({ events, warningEventsOnly, }: EventsContentProps) => React__default.JSX.Element;
/**
 * Props for Events
 *
 * @public
 */
interface EventsProps {
    involvedObjectName: string;
    namespace: string;
    clusterName: string;
    warningEventsOnly?: boolean;
}
/**
 * Retrieves and shows Kubernetes events for the given object
 *
 * @public
 */
declare const Events: ({ involvedObjectName, namespace, clusterName, warningEventsOnly, }: EventsProps) => React__default.JSX.Element;

/**
 * Arguments for useEvents
 *
 * @public
 */
interface EventsOptions {
    involvedObjectName: string;
    namespace: string;
    clusterName: string;
}
/**
 * Retrieves the events for the given object
 *
 * @public
 */
declare const useEvents: ({ involvedObjectName, namespace, clusterName, }: EventsOptions) => react_use_lib_useAsyncFn.AsyncState<kubernetes_models_v1.Event[]>;

/**
 * Props for ErrorList
 *
 * @public
 */
interface ErrorListProps {
    podAndErrors: PodAndErrors[];
}
/**
 * Shows a list of errors found on a Pod
 *
 * @public
 */
declare const ErrorList: ({ podAndErrors }: ErrorListProps) => React__default.JSX.Element;

type PodColumns = 'READY' | 'RESOURCE';
type PodsTablesProps = {
    pods: Pod$1 | V1Pod[];
    extraColumns?: PodColumns[];
    children?: React__default.ReactNode;
};
declare const PodsTable: ({ pods, extraColumns }: PodsTablesProps) => React__default.JSX.Element;

type ServicesAccordionsProps = {};
declare const ServicesAccordions: ({}: ServicesAccordionsProps) => React__default.JSX.Element;

type KubernetesContentProps = {
    entity: Entity;
    refreshIntervalMs?: number;
    children?: React__default.ReactNode;
};
declare const KubernetesContent: ({ entity, refreshIntervalMs, }: KubernetesContentProps) => React__default.JSX.Element;

/**
 * Context for Pod Metrics
 *
 * @public
 */
interface ResourceUtilizationProps {
    compressed?: boolean;
    title: string;
    usage: number | string;
    total: number | string;
    totalFormatted: string;
}
/**
 * Context for Pod Metrics
 *
 * @public
 */
declare const ResourceUtilization: ({ compressed, title, usage, total, totalFormatted, }: ResourceUtilizationProps) => React__default.JSX.Element;

/**
 * Props drilled down to the PodExecTerminal component
 *
 * @public
 */
interface PodExecTerminalProps {
    clusterName: string;
    containerName: string;
    podName: string;
    podNamespace: string;
}
/**
 * Executes a `/bin/sh` process in the given pod's container and opens a terminal connected to it
 *
 * @public
 */
declare const PodExecTerminal: (props: PodExecTerminalProps) => React__default.JSX.Element;

/**
 * Opens a terminal connected to the given pod's container in a dialog
 *
 * @public
 */
declare const PodExecTerminalDialog: (props: PodExecTerminalProps) => React__default.JSX.Element;

interface KubernetesObjects {
    kubernetesObjects?: ObjectsByEntityResponse;
    loading: boolean;
    error?: string;
}
declare const useKubernetesObjects: (entity: Entity, intervalMs?: number) => KubernetesObjects;

/**
 * Retrieves the provided custom resources related to the provided entity, refreshes at an interval.
 *
 * @public
 */
declare const useCustomResources: (entity: Entity, customResourceMatchers: CustomResourceMatcher[], intervalMs?: number) => KubernetesObjects;

declare const PodNamesWithErrorsContext: React__default.Context<Set<string>>;

declare const PodNamesWithMetricsContext: React__default.Context<Map<string, ClientPodStatus>>;

declare const GroupedResponsesContext: React__default.Context<GroupedResponses>;

declare const ClusterContext: React__default.Context<ClusterAttributes>;

/**
 * Context for Pod Metrics
 *
 * @public
 */
declare const PodMetricsContext: React__default.Context<Map<string, ClientPodStatus[]>>;
type PodMetricsMatcher = {
    metadata?: IObjectMeta;
};
/**
 * Find metrics matching the provided pod
 *
 * @public
 */
declare const usePodMetrics: (clusterName: string, matcher: PodMetricsMatcher) => ClientPodStatus | undefined;

/**
 * Context for detected errors
 *
 * @public
 */
declare const DetectedErrorsContext: React__default.Context<DetectedError[]>;
/**
 *
 * @public
 */
type ErrorMatcher = {
    metadata?: IIoK8sApimachineryPkgApisMetaV1ObjectMeta;
} & TypeMeta;
/**
 * Find errors which match the resource
 *
 * @public
 */
declare const useMatchingErrors: (matcher: ErrorMatcher) => DetectedError[];

export { Cluster, ClusterContext, ClusterLinksFormatter, ClusterLinksFormatterOptions, ContainerCard, ContainerCardProps, ContainerScope, CronJobsAccordions, CustomResources, DeploymentResources, DetectedError, DetectedErrorsByCluster, DetectedErrorsContext, EntityKubernetesContent, EntityKubernetesContentProps, ErrorList, ErrorListProps, ErrorMatcher, ErrorPanel, ErrorReporting, ErrorSeverity, Events, EventsContent, EventsContentProps, EventsOptions, EventsProps, FixDialog, FixDialogProps, GoogleKubernetesAuthProvider, GroupedResponses, GroupedResponsesContext, HorizontalPodAutoscalerDrawer, IngressesAccordions, JobsAccordions, KubernetesApi, KubernetesAuthProviders, KubernetesAuthProvidersApi, KubernetesBackendClient, KubernetesContent, KubernetesDrawer, KubernetesDrawerContent, KubernetesObjects, KubernetesProxyApi, KubernetesProxyClient, KubernetesStructuredMetadataTableDrawer, LinkErrorPanel, PendingPodContent, PendingPodContentProps, PodAndErrors, PodDrawer, PodExecTerminal, PodExecTerminalDialog, PodExecTerminalProps, PodLogs, PodLogsDialog, PodLogsDialogProps, PodLogsOptions, PodLogsProps, PodMetricsContext, PodMetricsMatcher, PodNamesWithErrorsContext, PodNamesWithMetricsContext, PodScope, PodsTable, ResourceRef, ResourceUtilization, Router, ServerSideKubernetesAuthProvider, ServicesAccordions, clusterLinksFormatters, detectErrors, formatClusterLink, isKubernetesAvailable, kubernetesApiRef, kubernetesAuthProvidersApiRef, kubernetesPlugin, kubernetesProxyApiRef, kubernetesPlugin as plugin, useCustomResources, useEvents, useKubernetesObjects, useMatchingErrors, usePodLogs, usePodMetrics };
